## ðŸ’¡ LeetCode Problem 1: Two Sum - A Foundational Interview Classic

The problem known as "Two Sum," LeetCode's Problem 1, is perhaps the most famous and foundational question in the world of technical interviews and competitive programming. It is classified as an "Easy" level problem but is critical because it tests a candidate's understanding of basic array manipulation, nested loops, and, most importantly, the strategic use of data structures like hash maps for optimization.

---

### The Problem Statement and Constraints

The core of the problem is straightforward: Given an array of integers, let's call it `nums`, and a specific integer `target`, the task is to find the indices of the *two* numbers in `nums` such that their sum equals the `target`. A few key constraints are usually specified. It is generally assumed that there will be **exactly one solution** for each input, and you may not use the **same element twice**. The result must be an array or list containing the **zero-based indices** of the two numbers. For example, if `nums = [2, 7, 11, 15]` and `target = 9`, the output should be `[0, 1]` because $nums[0] + nums[1] = 2 + 7 = 9$.

---

### Solution 1: The Brute-Force Approach (Time Complexity $O(n^2)$)

The most intuitive and simple approach is the brute-force method. This involves checking every possible pair of numbers in the array to see if they sum up to the target. This is achieved using **two nested loops**. The outer loop iterates through each element, $nums[i]$, and the inner loop iterates through every subsequent element, $nums[j]$ (where $j > i$) to ensure we don't use the same element twice and avoid checking the same pair twice. 

For an array of size $n$, the outer loop runs $n$ times. The inner loop, in the worst case, runs almost $n$ times for each iteration of the outer loop. This leads to a total time complexity proportional to $n^2$, or $O(n^2)$, which is acceptable for very small input sizes but highly inefficient for large arrays. Although simple to code, this quadratic time complexity is typically what interviewers want you to improve upon.

---

### Solution 2: The Optimized Approach using a Hash Map (Time Complexity $O(n)$)

The most efficient and generally preferred solution utilizes a hash map (or dictionary/hash table). The goal is to reduce the time complexity from $O(n^2)$ to $O(n)$, which is achieved by trading time for space. The core idea relies on the algebraic relationship $num_1 + num_2 = target$, which can be rearranged to find the required complement: $num_2 = target - num_1$.

The algorithm involves iterating through the `nums` array only once. For the current number $nums[i]$, we calculate its **complement** needed to reach the target, which is $target - nums[i]$. We then check if this calculated complement already exists as a key in our hash map.

---

### How the Hash Map Optimization Works

If the complement **is found** in the hash map, it means we have successfully found the two numbers that sum up to the target. We simply return the index of the complement (which is the value stored in the hash map) and the current index $i$. This lookup in a hash map takes, on average, $O(1)$ time (constant time).

If the complement **is not found**, we insert the current number $nums[i]$ and its corresponding index $i$ into the hash map. The key is the number, and the value is its index. This step is crucial: we are storing the numbers we have *already seen*, allowing us to quickly check if a future element is the necessary complement for a previous one. By performing a single pass over the array with constant time lookups and insertions, the overall time complexity is drastically reduced to $O(n)$. 

---

### The Importance of the Two Sum Problem

The "Two Sum" problem serves as an excellent gateway problem for understanding the power of hash maps in algorithm design. It demonstrates a common optimization technique: using an auxiliary data structure (the hash map) to store information about past iterations, thereby avoiding repeated calculations and drastically improving time efficiency. Mastering this problem and its optimal solution is often the first step in preparing for technical interviews, as it highlights a fundamental understanding of data structures and algorithmic complexity analysis, specifically the ability to move from a brute-force $O(n^2)$ solution to an optimal $O(n)$ solution.

***

Would you like to see a code example of the $O(n)$ Hash Map solution in a specific programming language, or explore a variation of this problem, such as "3Sum"?