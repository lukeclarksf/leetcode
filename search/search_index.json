{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LeetCode Python","text":"<p>This repository holds my Python solutions for various LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment.</p> <p>Static site generation is done with Python Make Docs.</p> <p>View source code here or on GitHub</p> <p>Luke Clark</p> <p>Contact at me lukeclarksf@gmail.com</p> <p>Look at my CV</p>"},{"location":"1/","title":"Problem 1","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"1/#leetcode-problem-1-two-sum","title":"\ud83d\udca1 LeetCode Problem 1: Two Sum","text":""},{"location":"1/#problem-description","title":"Problem Description","text":"<p>Given an array of integers, <code>nums</code>, and an integer, <code>target</code>, return the indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p>"},{"location":"1/#example","title":"Example","text":"<ul> <li>Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code></li> <li>Output: <code>[0, 1]</code></li> <li>Explanation: Because <code>nums[0] + nums[1] == 9</code>, we return <code>[0, 1]</code>.</li> </ul>"},{"location":"1/#approaches","title":"Approaches","text":"<p>There are a few ways to solve this problem, but the most efficient uses a Hash Map (or dictionary).</p>"},{"location":"1/#1-brute-force-inefficient","title":"1. Brute Force (Inefficient)","text":"<p>The simplest approach is to check every possible pair of numbers.</p> <ul> <li>Use a nested loop. The outer loop iterates from the first element up to the second-to-last element (<code>i</code>).</li> <li>The inner loop iterates from the element after the outer loop's current element up to the last element (<code>j</code>).</li> <li>In the inner loop, check if <code>nums[i] + nums[j]</code> equals <code>target</code>. If it does, return <code>[i, j]</code>.</li> </ul> Complexity Time Space Worst-Case \\(O(n^2)\\) \\(O(1)\\)"},{"location":"1/#2-two-pass-hash-map","title":"2. Two-Pass Hash Map","text":"<p>We can use a Hash Map to reduce the time complexity. A Hash Map allows us to look up an element in \\(O(1)\\) time on average.</p> <ol> <li>First Pass (Build Map): Iterate through the <code>nums</code> array and store each element's value as the key and its index as the value in the Hash Map.</li> <li>Second Pass (Find Complement): Iterate through the <code>nums</code> array again.<ul> <li>For the current number, \\(n_i = nums[i]\\), calculate the complement needed: \\(c = target - n_i\\).</li> <li>Check if the complement, \\(c\\), exists as a key in the Hash Map.</li> <li>Crucially: Ensure the index stored for the complement is not the current index \\(i\\).</li> <li>If the complement is found, return the current index \\(i\\) and the index stored in the map.</li> </ul> </li> </ol> Complexity Time Space Worst-Case \\(O(n)\\) \\(O(n)\\)"},{"location":"1/#3-one-pass-hash-map-optimal","title":"3. One-Pass Hash Map (Optimal)","text":"<p>We can combine the two passes into a single pass for optimal performance.</p> <ol> <li>Initialize an empty Hash Map.</li> <li>Iterate through the <code>nums</code> array with index \\(i\\).</li> <li>For the current number, \\(n_i = nums[i]\\), calculate the complement needed: \\(c = target - n_i\\).</li> <li>Check if the complement, \\(c\\), already exists as a key in the Hash Map.<ul> <li>If Found: We have found the solution! Return the complement's index (from the map) and the current index \\(i\\).</li> <li>If Not Found: Add the current number \\(n_i\\) and its index \\(i\\) to the Hash Map.</li> </ul> </li> </ol> <p>This works because by the time we check for the complement \\(c\\), any element that could be \\(c\\) has already been processed and stored in the map, unless \\(n_i\\) is its own complement (which is handled by the map not containing the current element's index).</p> Complexity Time Space Worst-Case \\(O(n)\\) \\(O(n)\\) ---"},{"location":"1/#why-the-one-pass-hash-map-is-optimal","title":"Why the One-Pass Hash Map is Optimal","text":"<p>The one-pass approach maintains the \\(O(n)\\) time complexity of the Two-Pass approach but only requires a single iteration through the list, making it generally faster in practice and the preferred solution. Both approaches trade extra \\(O(n)\\) space for a significant improvement in time complexity from \\(O(n^2)\\) to \\(O(n)\\).</p>"},{"location":"10/","title":"Problem 10","text":"<pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"2/","title":"Problem 2","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#leetcode-problem-2-add-two-numbers","title":"LeetCode Problem 2: Add Two Numbers","text":"Attribute Value Title Add Two Numbers Difficulty Medium Topics Linked List, Math URL LeetCode 2"},{"location":"2/#problem-description","title":"\u2753 Problem Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list (also in reverse order).</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>"},{"location":"2/#example","title":"Example","text":"<p>Input: <code>l1 = [2,4,3]</code>, <code>l2 = [5,6,4]</code> Output: <code>[7,0,8]</code> Explanation: \\(342 + 465 = 807\\). The output list represents \\(807\\) in reverse.</p>"},{"location":"2/#solution-approach-simulation-of-grade-school-addition","title":"\ud83d\udca1 Solution Approach: Simulation of Grade-School Addition","text":"<p>The structure of the input\u2014digits in reverse order\u2014is key. It means the head of the list corresponds to the ones place, allowing us to perform long addition by traversing the lists simultaneously from head to tail.</p>"},{"location":"2/#the-iterative-process","title":"The Iterative Process","text":"<p>We use an iterative approach, maintaining a <code>carry</code> variable to handle overflow whenever the sum of the digits exceeds \\(9\\).</p> <ol> <li>Initialize: A <code>dummy</code> node is created to anchor the result list, and a <code>current</code> pointer tracks the tail of the sum list. <code>carry</code> is set to \\(0\\).</li> <li>Iterate: We loop until both lists are exhausted AND the <code>carry</code> is \\(0\\).</li> <li>Summation: In each step, we calculate the sum of the current digits from \\(l1\\) and \\(l2\\) (using \\(0\\) if a list is exhausted) plus the incoming <code>carry</code>.</li> <li>Result &amp; Carry Update:<ul> <li>The digit for the new node is \\(sum \\pmod{10}\\).</li> <li>The new <code>carry</code> is \\(sum // 10\\).</li> </ul> </li> <li>List Building: A new node is created with the result digit and appended to the result list via the <code>current</code> pointer.</li> </ol>"},{"location":"3/","title":"Problem 3","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"4/","title":"Problem 4","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"},{"location":"5/","title":"Problem 5","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n</code></pre>"},{"location":"6/","title":"Problem 6","text":"<pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n</code></pre>"},{"location":"7/","title":"Problem 7","text":"<pre><code>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n</code></pre>"},{"location":"8/","title":"Problem 8","text":"<pre><code>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n</code></pre>"},{"location":"9/","title":"Problem 9","text":"<pre><code>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n</code></pre>"}]}