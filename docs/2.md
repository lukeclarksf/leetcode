## Pyodide

```pyodide
{% 
    include "../python_run/_2.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_2.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/add-two-numbers/"><input class="verify-button" type="button" value="Verify"/></a>


## Function Description

::: _2.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## Problem Statement

The goal is to sum two non-negative integers that are represented by two separate singly linked lists. The digits of each integer are stored in reverse order, with each node in the linked list containing a single digit. You must add the two numbers and return the result as a new singly linked list, also with its digits in reverse order. It can be assumed that the numbers do not contain any leading zeros, except for the number 0 itself.

## Concepts used

The core concept of LeetCode Problem 2, "Add Two Numbers," is to simulate the elementary school arithmetic addition process using the Singly Linked List data structure. Since the digits are stored in reverse order (least significant digit first), we can iterate through both lists simultaneously from the head. In each step of the iteration, we sum the corresponding digits from the two lists, along with any existing carry value from the previous step. We then determine the new digit for the result list using the modulo operator ($sum \pmod{10}$) and calculate the new carry for the next step using integer division ($sum // 10$). This continuous process of calculating the sum and propagating the carry is repeated until both input lists are fully traversed and the final carry value is zero. The use of a Dummy Head Node is a standard practice to streamline the construction of the result list without needing a special case for the very first node.

## Algorithm

The algorithm for LeetCode Problem 2, "Add Two Numbers," simulates the manual process of adding numbers, column by column, but adapted for Singly Linked Lists where digits are stored in reverse order (least significant digit at the head). The procedure involves initializing a carry variable (set to 0) and using a Dummy Head Node to simplify the construction of the result list. We then iterate through the input lists simultaneously as long as either list has nodes remaining or the carry value is non-zero. In each loop iteration, we calculate the total_sum by adding the current digits from both input nodes (using 0 if a node is null/exhausted) and the existing carry. The new digit for the result list is derived from the remainder of the sum ($total\_sum \pmod{10}$), and the new carry is the quotient ($total\_sum // 10$). A new node with the calculated digit is appended to the result list, and the pointers for the input lists and the result list are advanced. This iterative process efficiently handles varying list lengths and the final carry propagation, yielding the sum in the required linked list format.

## Example

The optimal algorithm for LeetCode Problem 1, "Two Sum," utilizes a One-Pass Hash Map (Dictionary) to achieve an $O(N)$ time complexity. Consider the input: nums = [2, 7, 11, 15] and target = 9. We iterate through the array, maintaining a map of values seen so far and their indices.Iteration 1 (Index 0, Value 2): We calculate the complement needed: $9 - 2 = 7$. Since 7 is not yet in the map, we store the current value-index pair: map = {2: 0}.Iteration 2 (Index 1, Value 7): The complement needed is $9 - 7 = 2$. We check the map and find that 2 exists (stored at index 0). This is our solution pair, so we immediately return the indices of the complement and the current value: [0, 1]. The single-pass approach ensures that we don't use the same element twice (since the current element at index 1 is checked against values stored from previous indices).

## Data Structures used

The primary data structure employed for the optimal solution to LeetCode Problem 1, "Two Sum," is the Hash Map (or dictionary in Python). This choice is critical for achieving the required time complexity efficiency. The Hash Map is utilized to store previously encountered numbers and their corresponding array indices. By leveraging the $\mathcal{O}(1)$ average time complexity for both key lookups and insertions inherent to hash maps, the algorithm can quickly determine if the necessary complement (i.e., $target - current\_number$) required to meet the target sum has already been processed. This direct, constant-time retrieval allows the entire search to be completed in a single pass through the input array, thus reducing the overall time complexity from the brute-force $\mathcal{O}(n^2)$ to the highly efficient $\mathcal{O}(n)$. The input itself is typically provided as an Array or List of integers, which is the initial data structure that the hash map optimizes access around.

## Complexity Analysis

The complexity analysis for the optimal solution to LeetCode Problem 1, "Two Sum," is dominated by the single iteration through the input list, resulting in a Time Complexity of $\mathcal{O}(n)$, where $n$ is the number of elements in the array. This linear time is achieved by utilizing a Hash Map to store seen numbers and their indices. Crucially, both the lookup for the required complement (target - current\_number) and the insertion of the current number are performed in average $\mathcal{O}(1)$ time, as hash map operations avoid extensive searching or sorting. Consequently, the total time required scales directly and linearly with the size of the input. Regarding Space Complexity, the solution requires an auxiliary hash map that, in the worst case (where the solution is found at the very end), will store up to $n$ elements, leading to a Space Complexity of $\mathcal{O}(n)$. This represents a classic space-time trade-off, prioritizing speed over minimal memory usage.