## Run

```pyodide
{% 
    include "../python_run/_1.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_1.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/two-sum/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _1.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## Problem Statement

The LeetCode problem 1. Two Sum requires you to find the indices of two numbers within a given array of integers, nums, that add up to a specific integer target. You must assume that there is exactly one valid solution for each input, and you are not allowed to use the same element twice (meaning the two indices must be different). The final output should be an array containing the two zero-based indices of the elements that satisfy the condition. For example, if nums = [2, 7, 11, 15] and target = 9, you should return [0, 1] because $nums[0] + nums[1] = 2 + 7 = 9$.

## Conceptual Approach

A conceptually efficient way to solve the Two Sum problem is by using a hash map (or dictionary) to reduce the time complexity from $O(n^2)$ to $O(n)$. The approach involves iterating through the nums array only once. For each number, $x$, at index $i$, we calculate the complement needed to reach the target: $complement = target - x$.  We then check if this $complement$ already exists as a key in our hash map. If it does, we have found the solution, and we return the index stored with the $complement$ and the current index $i$. If the $complement$ is not found, we add the current number $x$ and its index $i$ to the hash map. By storing the numbers encountered so far and their indices, we can perform a constant-time $O(1)$ lookup for the required complement, ensuring we find the solution in a single pass.

## Algorithm

The Two Sum algorithm utilizing a hash map proceeds as follows: Initialize an empty hash map, which will store the elements of nums encountered so far as keys, and their corresponding indices as values. Iterate through the input array nums from the first element to the last, keeping track of the current element's value (let's call it $x$) and its index ($i$). In each iteration, calculate the required complement as $C = target - x$. Check if $C$ already exists as a key in the hash map. If $C$ is found in the map, it means we have found the two numbers that sum up to target, and the algorithm immediately returns an array containing two indices: the value associated with key $C$ in the hash map, and the current index $i$. If $C$ is not found, the algorithm adds the current element $x$ and its index $i$ to the hash map and proceeds to the next element in nums. Since the problem guarantees exactly one solution, the algorithm is assured to terminate by finding and returning a pair of indices.

## Example

Let's walk through an example using the input $\text{nums} = [3, 5, 2, 8]$ and $\text{target} = 7$. We initialize an empty hash map, $H$.Iteration 1 (Index $i=0$): $\text{nums}[0] = 3$. The required $\text{complement}$ is $7 - 3 = 4$. $4$ is not in $H$. We add $(3, 0)$ to $H$.Iteration 2 (Index $i=1$): $\text{nums}[1] = 5$. The required $\text{complement}$ is $7 - 5 = 2$. $2$ is not in $H$. We add $(5, 1)$ to $H$.Iteration 3 (Index $i=2$): $\text{nums}[2] = 2$. The required $\text{complement}$ is $7 - 2 = 5$. $5$ is in $H$, and its stored index is $1$. Since we found the complement, we immediately return the pair of indices: $[\text{index associated with } 5, \text{ current index } i]$, which is $[1, 2]$.The walkthrough confirms that the pair of elements at indices $1$ and $2$ (which are $5$ and $2$) sum up to the $\text{target}$ of $7$, and the algorithm efficiently finds this solution in one pass.

## Data Structures used

The most efficient solution to LeetCode 1, the Two Sum problem, primarily relies on a single crucial data structure: the Hash Map (or Hash Table, sometimes called a Dictionary in some languages). This structure is essential because it allows for near-instantaneous, $O(1)$ average time complexity lookups.  The hash map is used to store the numbers encountered so far in the input array as the keys, and their corresponding zero-based indices as the values. By storing the index, we can instantly retrieve the required index for the complement number when it is encountered later in the iteration. Although the input array nums is also a data structure (a fixed-size array or list), it is the strategic use of the hash map that transforms the solution from a slow $O(n^2)$ search to a highly efficient $O(n)$ single-pass solution.

## Complexity Analysis

The one-pass hash map solution for the Two Sum problem achieves optimal complexity for both time and space. The Time Complexity is $O(n)$, where $n$ is the number of elements in the nums array. This is because we iterate through the array exactly once, and for each element, we perform two operations: a hash map lookup (to check for the complement) and a hash map insertion (to store the current element), both of which take an average of $O(1)$ time.

The overall Space Complexity is also $O(n)$, as in the worst-case scenario (where the solution is the last two elements), we store up to $n$ elements in the hash map. Each entry in the hash map stores a number and its index. This trade-off of $O(n)$ space for $O(n)$ time is significantly better than the naive $O(n^2)$ time complexity of a brute-force approach that uses $O(1)$ extra space.