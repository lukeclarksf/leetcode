## Run

```pyodide
{% 
    include "../python_run/_1.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_1.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/two-sum/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _1.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## Problem Statement

Given an array of integers, $nums$, and an integer target value, the objective is to identify the indices of the two numbers within the array that sum up precisely to the target.  It is guaranteed that exactly one valid solution exists in the input, and it is assumed that the same element cannot be used twice. The function must return an array or list containing the zero-based indices of the two elements that satisfy the condition.


## Concepts used

The most efficient and professional solution for the Two Sum problem leverages the concept of a Hash Map (or Dictionary) to reduce the time complexity from $O(n^2)$ to a superior $O(n)$. During a single pass through the input array, we check the Hash Map for the existence of the complement—the difference between the $target$ and the current element. If the complement is found, its associated index is immediately returned alongside the current element's index.  If the complement is not present, the current element and its index are added to the Hash Map, enabling a constant-time $O(1)$ lookup for subsequent elements, which is the crucial mechanism that achieves the linear overall time complexity.

## Algorithm

The optimal algorithm for the Two Sum problem employs a Hash Map data structure, which maps array values to their corresponding indices, allowing for efficient $O(1)$ average time lookups.  The process involves iterating through the $nums$ array exactly once. In each iteration, the algorithm calculates the complement required to reach the target (i.e., $complement = target - nums[i]$). It then immediately checks if this $complement$ already exists as a key in the Hash Map. If it does, the current index $i$ and the index stored under the $complement$ key are returned as the solution. If the $complement$ is not found, the algorithm adds the current element, $nums[i]$, and its index, $i$, to the Hash Map before proceeding to the next element. This single-pass method ensures a time complexity of $O(n)$ and a space complexity of $O(n)$ due to the storage required for the Hash Map.

## Example

Consider the example where $nums = [2, 7, 11, 15]$ and the $target = 9$. We initialize an empty Hash Map.  and target 9]Starting at index $i=0$ with value $2$, the $complement$ needed is $9 - 2 = 7$. Since $7$ is not in the Hash Map, we add $2$ with index $0$ to the map.Next, at index $i=1$ with value $7$, the $complement$ needed is $9 - 7 = 2$.We check the Hash Map and find that $2$ is present, and its stored index is $0$.Since we have found the two numbers, the algorithm immediately terminates and returns the indices $[0, 1]$.

## Data Structures used

The primary data structure employed for the most efficient solution is the Hash Map (or Hash Table), which is typically implemented as a dictionary in many programming languages.  This structure is indispensable because it facilitates near-constant time $O(1)$ average complexity for both insertion (storing the number and its index) and, most critically, lookup (checking for the existence of the required complement). The problem's input itself is an Array (or List) of integers, $nums$. The array serves as the structure that is iterated over, while the Hash Map is the auxiliary structure used to store previously visited elements, dramatically optimizing the search for the pair.

## Complexity Analysis

The optimal Hash Map-based solution achieves a time complexity of $O(n)$ (linear time). This efficiency stems from the fact that the algorithm iterates through the input array, $nums$, exactly once. Crucially, within this loop, the operations—calculating the complement and performing the Hash Map lookup and insertion—all execute in average constant time, $O(1)$.  In terms of space complexity, the solution is $O(n)$ (linear space). This is because, in the worst-case scenario (where the solution pair is the last two elements or the array is traversed entirely), the Hash Map will store up to $n$ elements, where $n$ is the number of elements in the input array.